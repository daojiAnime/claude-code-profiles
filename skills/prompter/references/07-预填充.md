# 预填充 Claude 的响应

## 什么是预填充？

预填充（Prefilling）是在 Claude 的响应开始处提供部分文本，引导 Claude 按照特定格式、风格或结构继续输出。

## 为什么使用预填充？

预填充可以：
- 🎯 强制特定的输出格式
- 📊 确保结构化响应
- 🔒 跳过不必要的客套话
- ⚡ 直接进入核心内容
- 📝 控制输出的开始方式

## 基本使用方式

### 方式 1: JSON 格式强制

**不使用预填充:**
```
请分析以下用户反馈的情感：
"这个产品太棒了！"

请以 JSON 格式返回结果。
```

**可能得到:**
```
好的，我来分析这条反馈的情感。这是一条明显的正面评价...

{
  "sentiment": "positive",
  "confidence": 0.95
}
```

**使用预填充:**
```
请分析以下用户反馈的情感：
"这个产品太棒了！"

{
```

**会得到:**
```json
{
  "sentiment": "positive",
  "confidence": 0.95,
  "keywords": ["产品", "棒"]
}
```

### 方式 2: 跳过客套话

**不使用预填充:**
```
简要回答: Python 中的列表和元组有什么区别？
```

**可能得到:**
```
好的，让我来解释一下 Python 中列表和元组的区别...
[实际内容]
```

**使用预填充:**
```
简要回答: Python 中的列表和元组有什么区别？

答:
```

**会得到:**
```
答: 列表是可变的，用方括号 []；元组是不可变的，用圆括号 ()。
列表适合需要修改的数据，元组适合固定不变的数据。
```

### 方式 3: 结构化输出

**任务:**
```
分析以下代码的时间复杂度:
[代码]

分析:
复杂度:
```

**Claude 会继续:**
```
分析:
1. 外层循环遍历 n 个元素
2. 内层循环同样遍历 n 个元素
3. 每次操作为 O(1)

复杂度: O(n²)
```

## 实用场景

### 场景 1: 代码生成

**预填充代码框架:**
```
创建一个 Python 函数来验证邮箱地址

```python
import re

def validate_email(email: str) -> bool:
    """
```

**Claude 继续:**
```python
import re

def validate_email(email: str) -> bool:
    """
    验证邮箱地址格式是否正确

    Args:
        email: 待验证的邮箱地址

    Returns:
        bool: 邮箱格式正确返回 True，否则返回 False
    """
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None
```

### 场景 2: 表格输出

**预填充表格头:**
```
列出 Python 常用的数据类型及其特点

| 类型 | 可变性 | 示例 | 用途 |
|------|--------|------|------|
```

**Claude 继续:**
```markdown
| 类型 | 可变性 | 示例 | 用途 |
|------|--------|------|------|
| list | 可变 | [1, 2, 3] | 存储有序可变集合 |
| tuple | 不可变 | (1, 2, 3) | 存储有序不可变集合 |
| dict | 可变 | {"a": 1} | 键值对映射 |
| set | 可变 | {1, 2, 3} | 存储唯一值集合 |
| str | 不可变 | "hello" | 文本数据 |
```

### 场景 3: XML/JSON 响应

**强制 XML 格式:**
```
将以下信息转换为 XML:
姓名: 张三, 年龄: 25, 城市: 北京

<person>
```

**Claude 继续:**
```xml
<person>
  <name>张三</name>
  <age>25</age>
  <city>北京</city>
</person>
```

### 场景 4: 分步骤回答

**预填充步骤框架:**
```
解释如何部署一个 Docker 应用

步骤 1:
```

**Claude 继续:**
```
步骤 1: 创建 Dockerfile
编写 Dockerfile 定义应用环境和依赖

步骤 2: 构建镜像
运行 `docker build -t app-name .` 构建镜像

步骤 3: 运行容器
执行 `docker run -p 8080:8080 app-name` 启动容器

步骤 4: 验证部署
访问 http://localhost:8080 检查应用状态
```

## 高级技巧

### 技巧 1: 组合标签和预填充

```
分析这段代码的问题

<analysis>
<问题列表>
1.
```

**Claude 被引导填充:**
```xml
<analysis>
<问题列表>
1. 缺少错误处理 - 当输入为空时会抛出异常
2. 变量命名不清晰 - 'x' 和 'y' 应该更具描述性
3. 没有类型提示 - 应添加类型注解提高可维护性
</问题列表>

<修复建议>
- 添加 try-except 块
- 重命名变量为有意义的名称
- 使用类型提示 (typing 模块)
</修复建议>
</analysis>
```

### 技巧 2: 多部分预填充

```
对比 REST 和 GraphQL

### REST
优点:
-
```

**继续第一部分后:**
```
对比 REST 和 GraphQL

### REST
优点:
- 成熟稳定，生态丰富
- 简单直观，易于理解
- 缓存机制完善

缺点:
```

### 技巧 3: 强制特定语言

```
用中文解释量子计算的基本原理

量子计算是
```

或

```
Explain quantum computing in English

Quantum computing is
```

### 技巧 4: 控制代码注释风格

**Python docstring 风格:**
```
def calculate_statistics(data):
    """
```

**JSDoc 风格:**
```javascript
/**
 * 计算数组统计信息
 *
```

## 实战示例

### 示例 1: API 响应格式

```
设计一个用户查询的 API 响应格式

{
  "status": "success",
  "data": {
    "user": {
```

**Claude 继续:**
```json
{
  "status": "success",
  "data": {
    "user": {
      "id": "12345",
      "name": "张三",
      "email": "zhang@example.com",
      "created_at": "2024-01-01T00:00:00Z",
      "profile": {
        "avatar": "https://example.com/avatar.jpg",
        "bio": "软件工程师"
      }
    }
  },
  "meta": {
    "request_id": "req_abc123",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

### 示例 2: 测试用例

```
为这个函数创建测试用例

```python
def is_palindrome(s: str) -> bool:
    # [实现代码]

# 测试用例
def test_is_palindrome():
    # 正常情况
    assert
```

**Claude 继续:**
```python
def is_palindrome(s: str) -> bool:
    # [实现代码]

# 测试用例
def test_is_palindrome():
    # 正常情况
    assert is_palindrome("noon") == True
    assert is_palindrome("hello") == False

    # 边界情况
    assert is_palindrome("") == True
    assert is_palindrome("a") == True

    # 大小写和空格
    assert is_palindrome("A man a plan a canal Panama") == False  # 需要预处理

    # 特殊字符
    assert is_palindrome("race car!") == False
```

### 示例 3: Markdown 文档

```
创建项目的 README.md

# My Project

## 简介

这是一个
```

**Claude 继续:**
```markdown
# My Project

## 简介

这是一个用于数据处理和分析的 Python 工具包，提供简洁的 API 和强大的功能。

## 特性

- 🚀 高性能数据处理
- 📊 丰富的可视化选项
- 🔧 灵活的配置系统
- 📝 完善的文档

## 安装

```bash
pip install my-project
```

## 快速开始

```python
from my_project import DataProcessor

processor = DataProcessor()
result = processor.process(data)
```

## 文档

完整文档请访问 [docs.example.com](https://docs.example.com)
```

## 最佳实践

### ✅ 推荐做法

1. **使用有意义的预填充**
   ```
   ✅ 答: (清晰地引导回答)
   ❌ A: (可能产生歧义)
   ```

2. **预填充完整的结构元素**
   ```
   ✅ <response>
   ❌ <resp (不完整)
   ```

3. **保持一致的格式**
   ```
   ✅ 连续使用相同的代码块标记
   ❌ 混合不同的格式约定
   ```

### ❌ 避免的陷阱

1. **预填充包含错误**
   ```
   ❌ {
       "name": 张三,  // 缺少引号
   ```

2. **过度约束**
   ```
   ❌ 预填充太多内容，限制了 Claude 的发挥空间
   ```

3. **不完整的语法**
   ```
   ❌ def function(  // 括号未闭合
   ```

## 快速参考

### JSON 预填充
```
{
  "
```

### 代码预填充
```python
def function_name():
    """
```

### 列表预填充
```
优点:
1.
```

### 表格预填充
```
| 列1 | 列2 |
|-----|-----|
|
```

### XML 预填充
```xml
<root>
  <item>
```

## 总结

预填充是强制输出格式的有力工具：

- 🎯 确保特定格式输出
- ⚡ 跳过冗余内容
- 📊 强制结构化响应
- 🔧 控制输出开始方式
- ✨ 提高响应的可用性和一致性
